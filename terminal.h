#pragma once
#ifndef TERMINAL_H
#define TERMINAL_H

typedef struct FilteredInput
{
    char* inp;
    int nbytes;
} FilteredInput;

typedef struct TerminalData
{
    FilteredInput finp;
    char CMD[4];
    const char* modestr;
    int mode;
    unsigned char bytecode;
    int bytes;
    long H,L;
} TermData;

TermData* TerminalCMD( char* , long );
unsigned char AssembleI( const char* , int );
FilteredInput FilterInput( char* , long );

typedef enum
{
    md_IMP = 0,
    md_IMM,
    md_ZP,
    md_ZPX,
    md_ZPY,
    md_ABS,
    md_ABX,
    md_ABY,
    md_INX,
    md_INY,
    md_REL,
    md_ACC,
    md_IND,
    ad_IMMH,
    ad_IMMD

} TerminalEnums;

unsigned char AssembleI(const char* i, int m)
{
    #define DECODE(IMP,IMM,ZP,ZPX,ZPY,ABS,ABX,ABY,INX,INY,REL,ACC,IND) (m==md_IMP)?IMP:(m==md_IMM)?IMM:(m==md_ZP)?ZP:(m==md_ZPX)?ZPX:(m==md_ZPY)?ZPY:(m==md_ABS)?ABS:(m==md_ABX)?ABX:(m==md_ABY)?ABY:(m==md_INX)?INX:(m==md_INY)?INY:(m==md_REL)?REL:(m==md_ACC)?ACC:(m==md_IND)?IND:0xFF;

    if(!strncmp(i,"ADC",3)) return DECODE(0xFF,0x69,0x65,0x75,0xFF,0x6D,0x7D,0x79,0x61,0x71,0xFF,0xFF,0xFF);
    if(!strncmp(i,"AND",3)) return DECODE(0xFF,0x29,0x25,0x35,0xFF,0x2D,0x3D,0x39,0x21,0x31,0xFF,0xFF,0xFF);
    if(!strncmp(i,"ASL",3)) return DECODE(0xFF,0xFF,0x06,0x16,0xFF,0x0E,0x1E,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"BCC",3)) return DECODE(0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x90,0xFF,0xFF);
    if(!strncmp(i,"BEQ",3)) return DECODE(0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,0xFF,0xFF);
    if(!strncmp(i,"BIT",3)) return DECODE(0xFF,0x24,0xFF,0xFF,0xFF,0x2C,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"BMI",3)) return DECODE(0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x30,0xFF,0xFF);
    if(!strncmp(i,"BNE",3)) return DECODE(0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xD0,0xFF,0xFF);
    if(!strncmp(i,"BPL",3)) return DECODE(0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x10,0xFF,0xFF);
    if(!strncmp(i,"BRK",3)) return DECODE(0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"BVC",3)) return DECODE(0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xB0,0xFF,0xFF);
    if(!strncmp(i,"BVS",3)) return DECODE(0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,0xFF,0xFF);
    if(!strncmp(i,"CLC",3)) return DECODE(0x18,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"CLD",3)) return DECODE(0xD8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"CLI",3)) return DECODE(0x58,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"CLV",3)) return DECODE(0xB8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"CMP",3)) return DECODE(0xFF,0xC9,0xC5,0xD5,0xFF,0xCD,0xDD,0xD9,0xC1,0xD1,0xFF,0xFF,0xFF);
    if(!strncmp(i,"CPX",3)) return DECODE(0xFF,0xE0,0xE4,0xFF,0xFF,0xEC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"CPY",3)) return DECODE(0xFF,0xC0,0xC4,0xFF,0xFF,0xCC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"DEC",3)) return DECODE(0xFF,0xFF,0xC6,0xD6,0xFF,0xCE,0xDE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"DEX",3)) return DECODE(0xCA,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"DEY",3)) return DECODE(0x88,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"EOR",3)) return DECODE(0xFF,0x49,0x45,0x55,0xFF,0x4D,0x5D,0x59,0x41,0x51,0xFF,0xFF,0xFF);
    if(!strncmp(i,"INC",3)) return DECODE(0xFF,0xFF,0xE6,0xF6,0xFF,0xEE,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"INX",3)) return DECODE(0xE8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"INY",3)) return DECODE(0xC8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"JMP",3)) return DECODE(0xFF,0xFF,0xFF,0xFF,0xFF,0x4C,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x6C);
    if(!strncmp(i,"JSR",3)) return DECODE(0xFF,0xFF,0xFF,0xFF,0xFF,0x20,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"LDA",3)) return DECODE(0xFF,0xA9,0xA5,0xB5,0xFF,0xAD,0xBD,0xB9,0xA1,0xB1,0xFF,0xFF,0xFF);
    if(!strncmp(i,"LDX",3)) return DECODE(0xFF,0xA2,0xA6,0xFF,0xB6,0xAE,0xBE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"LDY",3)) return DECODE(0xFF,0xA0,0xA4,0xB4,0xFF,0xAC,0xBC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"LSR",3)) return DECODE(0xFF,0xFF,0x46,0x56,0xFF,0x4E,0x5E,0xFF,0xFF,0xFF,0xFF,0x4A,0xFF);
    if(!strncmp(i,"NOP",3)) return DECODE(0xEA,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"ORA",3)) return DECODE(0xFF,0x09,0x05,0x15,0xFF,0x0D,0x1D,0x19,0x01,0x11,0xFF,0xFF,0xFF);
    if(!strncmp(i,"PHA",3)) return DECODE(0x48,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"PHP",3)) return DECODE(0x08,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"PLA",3)) return DECODE(0x68,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"PLP",3)) return DECODE(0x28,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"ROL",3)) return DECODE(0xFF,0xFF,0x26,0x36,0xFF,0x2E,0x3E,0xFF,0xFF,0xFF,0xFF,0x2A,0xFF);
    if(!strncmp(i,"ROR",3)) return DECODE(0xFF,0xFF,0x66,0x76,0xFF,0x6E,0x7E,0xFF,0xFF,0xFF,0xFF,0x6A,0xFF);
    if(!strncmp(i,"RTI",3)) return DECODE(0x40,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"RTS",3)) return DECODE(0x60,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"SBC",3)) return DECODE(0xFF,0xE9,0xE5,0xF5,0xFF,0xED,0xFD,0xF9,0xE1,0xF1,0xFF,0xFF,0xFF);
    if(!strncmp(i,"SEC",3)) return DECODE(0x38,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"SED",3)) return DECODE(0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"SEI",3)) return DECODE(0x78,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"STA",3)) return DECODE(0xFF,0x85,0x95,0x8D,0xFF,0x8D,0x9D,0x99,0x81,0x91,0xFF,0xFF,0xFF);
    if(!strncmp(i,"STX",3)) return DECODE(0xFF,0xFF,0x86,0xFF,0x96,0x8E,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"STY",3)) return DECODE(0xFF,0xFF,0x84,0x94,0xFF,0x8C,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"TAX",3)) return DECODE(0xAA,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"TAY",3)) return DECODE(0xA8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"TSX",3)) return DECODE(0xBA,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"TXA",3)) return DECODE(0x8A,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"TXS",3)) return DECODE(0x9A,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
    if(!strncmp(i,"TYA",3)) return DECODE(0x98,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);


    return 0xFF; // Return invalid instruction
}

FilteredInput FilterInput(char* CMD, long bytes)
{
    // Used for running terminal commands.
    #define filter(C) C!='\t'&&C!=' '&&C!='\n'
    register int i;
    unsigned int nbytes=0;
    for(i = 0; i < bytes; i++)
    {
        if(CMD[i]=='\0') break;
        if(filter(CMD[i])) nbytes++;
    }
    char* buffer = malloc(nbytes+1);
    buffer[nbytes] = '\0';
    nbytes = 0;
    for(i = 0; i < bytes; i++)
    {
        if(CMD[i]=='\0') break;
        if(filter(CMD[i]))
        {
            buffer[nbytes] = CMD[i];
            nbytes++;
        }
    }
    FilteredInput finput = (FilteredInput){buffer,nbytes};
    return finput;
}

// Terminal
TermData* AssembleCMD(char* CMD, long bytes, unsigned short PC)
{
    FilteredInput fCMD = FilterInput(CMD,bytes);
    char* buffer = fCMD.inp;
    int nbytes = fCMD.nbytes;
    if(nbytes < 3)
    {
        TermData* data = malloc(sizeof(TermData));
        data->bytecode = 0xFF;
        data->finp = fCMD;
        return data;
    }
    long opH=0;
    long opL=0;
    int modeactual;
    char instruction[4];
    instruction[3]='\0';
    char modechk[6];
    modechk[5]='\0';
    strncpy(instruction,buffer,3);
    strncpy(modechk,buffer+3,2);
    strncpy(modechk+2,buffer+(nbytes-3),3);
    int isize=1;
    // Check next set to determine mode
    // #Special Branch mode#
    if(!strncmp(instruction,"B",1) && strncmp(instruction,"BIT",3) && !strncmp(modechk,"$",1))
       modeactual = md_REL;
    // #IMM modes#
    else if(!strncmp(modechk,"#$",2))
        modeactual = ad_IMMH;
    else if(!strncmp(modechk,"#",1))
        modeactual = ad_IMMD;
    // #IND modes#
    else if(!strncmp(modechk,"($",2) && !strncmp(modechk+2,",X)",3))
        modeactual = md_INX;
    else if(!strncmp(modechk,"($",2) && !strncmp(modechk+2,"),Y",3))
        modeactual = md_INY;
    // #ZP modes#
    else if(!strncmp(modechk,"$",1) && !strncmp(modechk+3,",X",2) && nbytes<9)
        modeactual = md_ZPX;
    else if(!strncmp(modechk,"$",1) && !strncmp(modechk+3,",Y",2) && nbytes<9)
        modeactual = md_ZPY;
    else if(!strncmp(modechk,"$",1) && nbytes<7)
        modeactual = md_ZP;
    // #ABS modes#
    else if(!strncmp(modechk,"$",1) && !strncmp(modechk+3,",X",2))
        modeactual = md_ABX;
    else if(!strncmp(modechk,"$",1) && !strncmp(modechk+3,",Y",2))
        modeactual = md_ABY;
    else if(!strncmp(modechk,"$",1))
        modeactual = md_ABS;
    else if(nbytes==3)
        modeactual = md_IMP;
    else // Oof, you done messed up, kid.
    {
        TermData* data = malloc(sizeof(TermData));
        data->bytecode = 0xFF;
        data->finp = fCMD;
        return data;
    }

    // Operand loading.
    char op[2];
    switch(modeactual)
    {
        case md_IMP: break;
        case ad_IMMH:
            strncpy(op,buffer+5,2);
            opH = strtol(op,NULL,16);
            isize++;
            modeactual = md_IMM;
        break;
        case ad_IMMD:
            strncpy(op,buffer+4,2);
            opH = strtol(op,NULL,10);
            isize++;
            modeactual = md_IMM;
        break;
        case md_ZPY:
        case md_ZPX:
        case md_ZP :
            strncpy(op,buffer+4,2);
            opH = strtol(op,NULL,16);
            isize++;
        break;
        case md_ABY:
        case md_ABX:
        case md_ABS:
            strncpy(op,buffer+4,2);
            opL = strtol(op,NULL,16);
            strncpy(op,buffer+6,2);
            opH = strtol(op,NULL,16);
            isize+=2;
        break;
        case md_INY:
        case md_INX:
            strncpy(op,buffer+5,2);
            opH = strtol(op,NULL,16);
            isize++;
        break;
        case md_REL:
            if(nbytes>6)
            {
                // Convert from ABS to REL
                char op[2];
                strncpy(op,buffer+4,2);
                opH = strtol(op,NULL,16);
                strncpy(op,buffer+6,2);
                opL = strtol(op,NULL,16);
                unsigned short abs  = (unsigned short)(opH*256)+opL;
                signed char rel = (signed char)(abs-PC)-2; // -2 for BNE bytes.
                opH = (unsigned char)rel;
                printf("$%04X -> %02X\n",abs,(unsigned char)rel);
            }
            else
            {
                strncpy(op,buffer+4,2);
                opH = strtol(op,NULL,16);
            }
            isize++;
        break;
    }
    const char* strmodes[12] =
    {
        "IMP",
        "IMM",
        "ZP",
        "ZPX",
        "ZPY",
        "ABS",
        "ABX",
        "ABY",
        "INX",
        "INY",
        "REL",
        "ACC"
    };
    //free(buffer);
    TermData* data = malloc(sizeof(TermData));
    strncpy(data->CMD,instruction,4);
    data->finp = fCMD;
    data->bytes = isize;
    data->mode = modeactual;
    data->modestr = strmodes[modeactual];
    data->H = opH;
    data->L = opL;
    data->bytecode = AssembleI(instruction,modeactual);
    return data;
}

#endif // TERMINAL_H

